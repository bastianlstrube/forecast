#pragma kernel AdvectParticles

#define threads_per_group_x 8
#define threads_per_group_y 8
#define threads_per_group_z 8

#define findID(mapX, mapY, mapZ) (mapX + totalThreadsX * (mapY + totalThreadsY * mapZ))

float timeStep;

// struct representing the data of a single particle
struct particle
{
	float3 position;
	float3 direction;
	float4 color;
	float timeElapsed;
	float lifeSpan;
	float3 spawnPosition;
	float drag;
	float velocity;
};

StructuredBuffer<float3> flowBuffer;			// array of vectors
RWStructuredBuffer<particle> particleBuffer;	// array of particles

int numThreadGroupsX;	// total number of thread groups
int numThreadGroupsY;	// total number of thread groups
int numThreadGroupsZ;	// total number of thread groups

float3 velocityBoxSize;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

float drag;

int velocityAlpha;

[numthreads(512, 1, 1)]
void AdvectParticles(uint3 dispatchID : SV_DispatchThreadID)
{
	// calculate total threads in the each dimension of whole box volume
	int totalThreadsX = threads_per_group_x * numThreadGroupsX;
	int totalThreadsY = threads_per_group_y * numThreadGroupsY;
	int totalThreadsZ = threads_per_group_z * numThreadGroupsZ;

	int totalThreads = totalThreadsX * totalThreadsY * totalThreadsZ;

	int particleID = dispatchID.x;
	//(dispatchID.x) + ((dispatchID.y) * totalThreadsX) + ((dispatchID.z) * totalThreadsX * totalThreadsY);
	
	if (particleBuffer[particleID].timeElapsed > particleBuffer[particleID].lifeSpan) {
		particleBuffer[particleID].timeElapsed = 0;
		particleBuffer[particleID].position = particleBuffer[particleID].spawnPosition;
		particleBuffer[particleID].velocity = 0.2f;
	}

	int bottomX = floor(particleBuffer[particleID].position.x);
	int bottomY = floor(particleBuffer[particleID].position.y);
	int bottomZ = floor(particleBuffer[particleID].position.z);
	int topX = ceil(particleBuffer[particleID].position.x);
	int topY = ceil(particleBuffer[particleID].position.y);
	int topZ = ceil(particleBuffer[particleID].position.z);

	float x = particleBuffer[particleID].position.x - (float)bottomX;
	float y = particleBuffer[particleID].position.y - (float)bottomY;
	float z = particleBuffer[particleID].position.z - (float)bottomZ;

	float3 value = flowBuffer[findID(bottomX, bottomY, bottomZ)] * (1 - x) * (1 - y) * (1 - z) +
		flowBuffer[findID(topX, bottomY, bottomZ)] * x * (1 - y) * (1 - z) +
		flowBuffer[findID(bottomX, topY, bottomZ)] * (1 - x) * y * (1 - z) +
		flowBuffer[findID(bottomX, bottomY, topZ)] * (1 - x) * (1 - y) * z +
		flowBuffer[findID(topX, bottomY, topZ)] * x * (1 - y) * z +
		flowBuffer[findID(bottomX, topY, topZ)] * (1 - x) * y * z +
		flowBuffer[findID(topX, topY, bottomZ)] * x * y * (1 - z) +
		flowBuffer[findID(topX, topY, topZ)] * x * y * z;

	particleBuffer[particleID].direction += value;
	particleBuffer[particleID].velocity *= drag;
	//particleBuffer[particleID].velocity *= particleBuffer[particleID].drag;

	particleBuffer[particleID].timeElapsed += timeStep;

	float percentOfLifespan = saturate(particleBuffer[particleID].timeElapsed / particleBuffer[particleID].lifeSpan);

	float3 direction = particleBuffer[particleID].direction;
	float magnitude = sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);

	particleBuffer[particleID].direction = particleBuffer[particleID].direction / magnitude;
	
	float alphaScale = saturate(velocityAlpha + magnitude / 2);
	float3 scaledPosition = particleBuffer[particleID].position / velocityBoxSize;

	particleBuffer[particleID].color = float4(1.0f, 1.0f, 1.0f, 1.0f);
	particleBuffer[particleID].color = float4(scaledPosition.x, scaledPosition.y, scaledPosition.z, (1 - percentOfLifespan)*alphaScale);

	particleBuffer[particleID].position += particleBuffer[particleID].direction * particleBuffer[particleID].velocity;
}