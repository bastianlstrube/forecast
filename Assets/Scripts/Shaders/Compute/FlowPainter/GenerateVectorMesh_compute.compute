#pragma kernel GenerateVectorMesh

#define threads_per_group_x 8
#define threads_per_group_y 8
#define threads_per_group_z 8

#define findID(mapX, mapY, mapZ) (mapX + totalThreadsX * (mapY + totalThreadsY * mapZ))

struct vectorPoint
{
	float3 position;
	float4 color;
};

StructuredBuffer<float3> vectorMapBuffer;	// 1 dimensional array of particles
RWStructuredBuffer<vectorPoint> meshPointBuffer;	// 1 dimensional array of particles
int numThreadGroupsX;	// total number of thread groups
int numThreadGroupsY;	// total number of thread groups
int numThreadGroupsZ;	// total number of thread groups

float brushSize;
float3 brushPosition;

[numthreads(threads_per_group_x, threads_per_group_y, threads_per_group_z)]
void GenerateVectorMesh(uint3 dispatchID : SV_DispatchThreadID)
{
	// calculate total threads in the each dimension of whole box volume
	int totalThreadsX = threads_per_group_x * numThreadGroupsX;
	int totalThreadsY = threads_per_group_y * numThreadGroupsY;
	int totalThreadsZ = threads_per_group_z * numThreadGroupsZ;

	int totalThreads = totalThreadsX * totalThreadsY * totalThreadsZ;

	// calculate the ID of this particle in the 1 dimensional array (flatten out 3D dispatch coordinates)
	int bufferID = findID(dispatchID.x, dispatchID.y, dispatchID.z);

	float3 pos = float3(dispatchID.x, dispatchID.y, dispatchID.z);
	float4 col = float4(0.5f, 0.5f, 1.0f, 0.05f);

	float3 difference = (pos - brushPosition);

	if (sqrt(difference.x * difference.x + difference.y * difference.y + difference.z * difference.z) <= brushSize)
		col = float4(1.0f, 0.5f, 0.5f, 0.7f);

	meshPointBuffer[(bufferID * 2)].position = pos;
	meshPointBuffer[(bufferID * 2)].color = col;
	meshPointBuffer[(bufferID * 2) + 1].position = pos + (vectorMapBuffer[bufferID]);
	meshPointBuffer[(bufferID * 2) + 1].color = col;
}
