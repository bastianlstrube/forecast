#pragma kernel MoveParticles

#define threads_per_group_x 8
#define threads_per_group_y 8
#define threads_per_group_z 8

#define findID(mapX, mapY, mapZ) (mapX + totalThreadsX * (mapY + totalThreadsY * mapZ))

float timeStep;
float currentTime;

// struct representing the data of a single particle
struct particle
{
	float3 position;
	float3 direction;
	float4 color;
	float timeElapsed;
	float lifeSpan;
	float3 spawnPosition;
	float drag;
	float velocity;
	float baseVelocity;
	float scale;
	float4 emissive;
};

StructuredBuffer<float3> flowBuffer;			// array of vectors
StructuredBuffer<float3> realtimeFlowMapBuffer;
RWStructuredBuffer<particle> particleBuffer;	// array of particles

int numThreadGroupsX;	// total number of thread groups
int numThreadGroupsY;	// total number of thread groups
int numThreadGroupsZ;	// total number of thread groups

float3 velocityBoxSize;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

float drag;

float2 fold;
float2 translate;
float scale;

int velocityAlpha;

float pulse;

float3 hsv(float h, float s, float v) {
	return lerp(float3(1.0f, 1.0f, 1.0f), clamp((abs(frac(h + float3(3.0f, 2.0f, 1.0f) / 3.0f)*6.0f - 3.0f) - 1.0f), 0.0f, 1.0f), s)*v;
}

float2 rotate(float2 p, float a) {
	return float2(p.x*cos(a) - p.y*sin(a), p.x*sin(a) + p.y*cos(a));
}

[numthreads(512, 1, 1)]
void MoveParticles(uint3 dispatchID : SV_DispatchThreadID)
{
	// calculate total threads in the each dimension of whole box volume
	int totalThreadsX = threads_per_group_x * numThreadGroupsX;
	int totalThreadsY = threads_per_group_y * numThreadGroupsY;
	int totalThreadsZ = threads_per_group_z * numThreadGroupsZ;

	int totalThreads = totalThreadsX * totalThreadsY * totalThreadsZ;

	int particleID = dispatchID.x;
	//(dispatchID.x) + ((dispatchID.y) * totalThreadsX) + ((dispatchID.z) * totalThreadsX * totalThreadsY);
	
	if (particleBuffer[particleID].timeElapsed > particleBuffer[particleID].lifeSpan) {
		particleBuffer[particleID].timeElapsed = 0;
		particleBuffer[particleID].position = particleBuffer[particleID].spawnPosition;
	}

	int bottomX = floor(particleBuffer[particleID].position.x);
	int bottomY = floor(particleBuffer[particleID].position.y);
	int bottomZ = floor(particleBuffer[particleID].position.z);
	int topX = ceil(particleBuffer[particleID].position.x);
	int topY = ceil(particleBuffer[particleID].position.y);
	int topZ = ceil(particleBuffer[particleID].position.z);

	float x = particleBuffer[particleID].position.x - (float)bottomX;
	float y = particleBuffer[particleID].position.y - (float)bottomY;
	float z = particleBuffer[particleID].position.z - (float)bottomZ;

	float3 value = flowBuffer[findID(bottomX, bottomY, bottomZ)] * (1 - x) * (1 - y) * (1 - z) +
		flowBuffer[findID(topX, bottomY, bottomZ)] * x * (1 - y) * (1 - z) +
		flowBuffer[findID(bottomX, topY, bottomZ)] * (1 - x) * y * (1 - z) +
		flowBuffer[findID(bottomX, bottomY, topZ)] * (1 - x) * (1 - y) * z +
		flowBuffer[findID(topX, bottomY, topZ)] * x * (1 - y) * z +
		flowBuffer[findID(bottomX, topY, topZ)] * (1 - x) * y * z +
		flowBuffer[findID(topX, topY, bottomZ)] * x * y * (1 - z) +
		flowBuffer[findID(topX, topY, topZ)] * x * y * z;

	float velocity = value.x * value.x + value.y * value.y + value.z * value.z;

	float3 value2 = realtimeFlowMapBuffer[findID(bottomX, bottomY, bottomZ)] * (1 - x) * (1 - y) * (1 - z) +
		realtimeFlowMapBuffer[findID(topX, bottomY, bottomZ)] * x * (1 - y) * (1 - z) +
		realtimeFlowMapBuffer[findID(bottomX, topY, bottomZ)] * (1 - x) * y * (1 - z) +
		realtimeFlowMapBuffer[findID(bottomX, bottomY, topZ)] * (1 - x) * (1 - y) * z +
		realtimeFlowMapBuffer[findID(topX, bottomY, topZ)] * x * (1 - y) * z +
		realtimeFlowMapBuffer[findID(bottomX, topY, topZ)] * (1 - x) * y * z +
		realtimeFlowMapBuffer[findID(topX, topY, bottomZ)] * x * y * (1 - z) +
		realtimeFlowMapBuffer[findID(topX, topY, topZ)] * x * y * z;

	float velocity2 = value2.x * value2.x + value2.y * value2.y + value2.z * value2.z;

	particleBuffer[particleID].velocity += (velocity+velocity2) * 0.1f;

	particleBuffer[particleID].direction += value + value2;
	particleBuffer[particleID].velocity *= drag;
	//particleBuffer[particleID].velocity *= particleBuffer[particleID].drag;

	particleBuffer[particleID].timeElapsed += timeStep;

	float percentOfLifespan = saturate(particleBuffer[particleID].timeElapsed / particleBuffer[particleID].lifeSpan);

	float3 direction = particleBuffer[particleID].direction;
	float magnitude = sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);

	particleBuffer[particleID].direction = particleBuffer[particleID].direction / magnitude;
	
	float alphaScale = saturate(velocityAlpha + magnitude / 2);
	float3 scaledPosition = particleBuffer[particleID].position / velocityBoxSize;

	
	//particleBuffer[particleID].color = float4(scaledPosition.x, scaledPosition.y, scaledPosition.z, (1 - percentOfLifespan)*alphaScale);
	
	float pulseToDepth = saturate((particleBuffer[particleID].position.z - pulse*velocityBoxSize.z) / velocityBoxSize.z);
	//particleBuffer[particleID].color = float4(pulseToDepth*5.0f, 0.0f, 5.0f, pulseToDepth + 0.1f);

	particleBuffer[particleID].color = float4(scaledPosition.y, scaledPosition.x, scaledPosition.z-0.5f, alphaScale);

	particleBuffer[particleID].emissive = float4(pulseToDepth*0.1f, pulseToDepth*0.1f, pulseToDepth*3.0f, pulseToDepth * 10.0f);

	/*PERSIAN CARPET*/
	/*
	float2 p = -5.0 + 10.0*scaledPosition.xy;
	p.x *= velocityBoxSize.x / velocityBoxSize.y;
	p *= 0.003f;
	float px = p.y;
	p = abs((p%8.0f) - 4.0f);

	for (int i = 0; i < 36; i++)
	{
		p = abs(p - fold) + fold;
		p = p*scale - translate;
		p = rotate(p, 3.14159f / (8.0f + sin(currentTime*0.001f + float(i)*0.1f)*0.5f + 0.5f));
	}

	float j = px*10.0 + atan2(p.x, p.y) + currentTime*0.5f;
	float h = floor(j*6.0f) / 5.0f + 0.07f;
	h += smoothstep(0.0f, 0.4f, (j*6.0f / 5.0f)%(1.0f / 5.0f)*5.0f) / 5.0f - 0.5f;
	particleBuffer[particleID].color = float4(hsv(h, 1.0, smoothstep(-1.0, 3.0, length(p))), 1.0f);
	*/
	//particleBuffer[particleID].color = float4(1.0f, 1.0f, 1.0f, 1.0f);
	particleBuffer[particleID].position += particleBuffer[particleID].direction * particleBuffer[particleID].velocity;
}

